# 互斥体
尽管信号量已经可以实现互斥的功能，但是"正宗"的mutex在内核中还是真实地存在着。

下面的代码定义了名为my_mutex的互斥体，并初始化它：
```c
struct mutex my_mutex;
mutex_init(&my_mutex);
```

下面的函数用于获取互斥体：
```c
void mutex_lock(struct mutex *lock);
int mutex_lock_interruptible(struct mutex *lock);
int mutex_trylock(struct mutex *lock);
```
mutex_lock()与mutex_lock_interruptible()的区别和down()和down_interruptible()的区别完全一致，前者引起的睡眠不能被信号打断，而后者可以。mutex_trylock()用于尝试获取mutex，获取不到不会引起进程睡眠。

下列函数用于释放互斥体：
```c
void mutex_unlock(struct mutex *lock);
```

mutex使用方法和信号量用于互斥的场合完全一样：
```c
struct mutex my_mutex; /* 定义mutex */
mutex_init(&my_mutex); /* 初始化mutex */
mutex_lock(&my_mutex); /* 获取mutex */
...						/* 临界资源 */
mutex_unlock(&my_mutex); /* 释放mutex */
```

自旋锁和互斥体都是解决互斥问题的基本手段，面对特定情况，应该如何取舍这两种情况呢？选择的依据是临界区的性质和系统的特点。

从严格意义上说，互斥体和自旋锁属于不同层次上的互斥手段，前者的实现依赖于后者。在互斥体本身的实现上，为了保证互斥体结构存取的原子性，需要自旋锁来互斥，所以自旋锁属于更底层的手段。

互斥体是进程级的，用于多个进程之间对资源的互斥，虽然也是在内核中，但是该内核执行路径是以进程的身份，代表进程来争夺资源的。如果竞争失败，会发生进程上下文切换，当前进程进入睡眠状态，CPU将运行其他进程。鉴于进程上下文切换的开销也很大，因此，只有当进程占用资源时间较长时，用互斥体才是较好的选择。

当所要保护的临界区访问时间较短时，用自旋锁是非常方便的，因为它可节省上下文切换的时间。但是CPU得不到自旋锁会在那里空转直到其他进程释放自旋锁为止，所以要求锁不能在临界区里长时间停留，否则会降低系统的效率。

由此，可以总结出自旋锁和互斥体选用的3项原则：  
1). 当锁不能被获取到时，使用互斥体的开销是进程上下文的切换时间，使用自旋锁的开销是等待获取自旋锁（由临界区执行时间决定）。若临界区比较小，宜使用自旋锁，若临界区很大，应使用互斥体。  
2). 互斥体所保护的临界区可包含可能引起阻塞的代码，而自旋锁绝对要避免用来保护包含这样代码的临界区。因为阻塞意味着要进行进程的切换，如果进程被切换出去，另一个进程企图获取本自旋锁，死锁就会发生。  
3). 互斥体存在于进程上下文，因此，如果要保护的共享资源需要在中断或软中断情况下使用，则在自旋锁和互斥体之间只能选择自旋锁。当然，如果一定要使用互斥体，只能使用mutex_trylock()，不能获取就立刻返回以避免阻塞。