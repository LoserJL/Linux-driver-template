# 阻塞与非阻塞I/O
阻塞操作是指，在执行设备操作时，若不能获得资源，则挂起进程直到满足可操作的条件后再进行操作。被挂起的进程进入睡眠状态，被从调度器的运行队列移走，直到等待的条件被满足。而非阻塞操作的进程在不能进行设备操作时，并不挂起，它要么放弃，要么不断查询，直至可以进行操作为止。

驱动程序通常需要提供这样的能力：当应用程序执行read()、write()等系统调用时，若设备的资源不能获取，而用户又希望以阻塞的方式访问设备，驱动程序应在设备驱动的xxx_read()、xxx_write()等操作中将进程阻塞知道资源可以获取，此后，应用程序的read()、write()等调用才返回，整个过程仍然进行了正确的设备访问，用户并没有感知到；若用户以非阻塞的方式访问设备文件，则当设备资源不可获取时，设备驱动的xxx_read()、xxx_write()等操作应立即返回，read()、write()等系统调用也随即被返回，应用程序收到-EAGAIN返回值。

在阻塞访问时，不能获取资源的进程将进入休眠，它将CPU资源“礼让”给其他进程。因为阻塞的进程会进入休眠，所以必须确保有一个地方能够唤醒休眠的进程，否则，进程就真的“寿终正寝”了。唤醒进程的地方最大可能发生在中断里，因为在硬件资源获得的同时往往伴随着一个中断。而非阻塞的进程不断尝试，直至可以进行I/O。

下面两段代码分别演示了以阻塞和非阻塞方式读取串口一个字符的代码。前者在打开文件时没有O_NONBLOCK标记，后者使用O_NONBLOCK标记打开文件。

**阻塞地读串口一个字符**
```c
char buf;
fd = open("/dev/ttyS1", O_RDWR);
...
res = read(fd, &buf, 1);	/* 当串口上有输入时才返回 */
if (res == 1)
	printf("%c\n", buf);
```

**非阻塞地读串口一个字符**
```c
char buf;
fd = open("/dev/ttyS1", O_RDWR | O_NONBLOCK);
...
while(read(fd, &buf, 1) != 1)
	continue;		/* 串口上无输入也返回，因此要不断尝试 */
printf("%c\n", buf);
```

除了在打开文件时可以指定是阻塞还是非阻塞方式以外，在文件打开后，也可以通过ioctl()和fcntl()改变读写的方式，如从阻塞变更为非阻塞或者从非阻塞变更为阻塞。例如：
```c
fcntl(fd, F_SETFL, O_NONBLOCK);
```
可以设置fd对应的I/O为非阻塞。

## 等待队列
